# 치맵(ChiMap) — Vector DB + AI 개인화 추천  
우선순위 백로그 + 유저스토리별 기술/구현 가이드 (참고용)

> 목표: **MVP는 “개인화 추천이 된다”를 증명**하고, 지도/리스트 2화면 UX에서 자연스럽게 반복 사용을 만들기.  
> 원칙: **추천 후보 선정은 규칙/점수**, **LLM은 설명문(근거 기반)만** 생성.  
> Vector DB는 **텍스트(리뷰/요약) 의미 검색 + 유사 매장**에 사용.



에픽 1) 온보딩 & 동의

(신규 사용자) 앱을 처음 실행하면 위치 권한 요청을 받고, 거부해도 “동네/역 검색”으로 시작할 수 있다.

(신규 사용자) 개인정보/추천을 위한 데이터 사용(위치, 클릭/저장 로그, 리뷰 텍스트)의 범위를 확인하고 동의 수준을 선택할 수 있다(필수/선택 구분).

(신규 사용자) “치킨 취향 30초 설정”을 통해 바삭함/양념/매운맛/기름민감/가성비 등 선호를 슬라이더로 입력할 수 있다.

에픽 2) 데이터 수집(평가/행동 로그)

(사용자) 가게를 방문/주문한 후 “간단 평가(5항목)”를 10초 내에 남길 수 있다(바삭, 기름, 간, 양념, 재주문).

(사용자) 자유 텍스트 리뷰를 남길 수 있고, 시스템은 리뷰를 임베딩하여 개인화에 활용한다(벡터DB 저장).

(사용자) 가게를 “저장(찜)”하거나 “관심없음/차단”할 수 있고, 이 행동이 추천에 반영된다.

(사용자) “상황 태그(혼술/야식/가족/맥주)”를 선택해 추천을 요청할 수 있고, 선택한 태그가 이후 추천 프로필에 누적 반영된다.

에픽 3) 개인화 추천(핵심 경험)

(사용자) 현재 위치 기준으로 “오늘의 추천 5곳”을 받을 수 있다(영업중/거리/혼잡도 옵션).

(사용자) 추천 결과에서 “왜 추천했는지”를 한 줄로 확인할 수 있다(예: “바삭 선호 + 기름민감 매칭 상위”).

(사용자) 추천 결과를 “거리순/취향매칭순/가성비순”으로 정렬 변경할 수 있다.

(사용자) 추천 카드에서 “비슷한 취향 사용자들이 좋아한 메뉴/주문 조합”을 볼 수 있다(텍스트 기반이면 임베딩 유사도).

(사용자) 추천에서 마음에 들지 않는 경우 “이런 건 빼줘(예: 너무 느끼한 곳, 양념만)” 같은 자연어로 피드백할 수 있고, AI가 이를 선호/비선호 규칙으로 변환해 즉시 반영한다.

에픽 4) 지도/리스트 UX

(사용자) 추천 리스트와 동일한 대상이 지도 핀으로 표시되며, 필터/반경이 두 화면에서 유지된다.

(사용자) 지도에서 핀을 누르면 추천 이유/대표 메뉴/평가 요약이 바텀시트로 뜬다.

(사용자) “이 지역 다시 검색”을 눌러 현재 지도 중심 기준으로 추천을 재계산할 수 있다.

에픽 5) 벡터DB 기반 검색 & 유사 매장

(사용자) “겉바속촉 + 기름 냄새 적은 곳”처럼 문장으로 검색하면, AI가 리뷰/특징 임베딩 유사도 기반으로 후보를 찾고 리스트로 보여준다.

(사용자) 특정 가게 상세에서 “이 가게랑 비슷한 곳”을 볼 수 있다(가게 임베딩/리뷰 임베딩 기반).

(사용자) 메뉴(후라이드/간장/양념/숯불 등) 단위로도 “비슷한 메뉴 맛집” 추천을 받을 수 있다(메뉴 프로필/리뷰 임베딩).

에픽 6) 품질/신뢰(미쉐린 느낌 유지)

(사용자) 리뷰가 과장/광고로 의심되면 신고할 수 있고, 시스템은 텍스트 모델로 1차 분류 후 운영자 큐에 올린다.

(운영자/평가단) 특정 매장은 “치맵 셀렉트”로 선정/해제할 수 있고, 선정 근거(점수/리뷰 요약/재방문 수)가 함께 기록된다.

(사용자) 치맵 셀렉트는 “광고/제휴와 무관” 같은 정책 문구와 함께 표시되어 신뢰를 확보한다.

에픽 7) 계정/프라이버시/데이터 관리

(사용자) 내 추천 프로필(취향 슬라이더, 선호 태그)을 확인/수정할 수 있다.

(사용자) 위치 기록/리뷰/추천 로그를 내려받기/삭제할 수 있다(개인정보 대응).

(사용자) “추천에 내 리뷰 텍스트 사용 안 함” 같은 옵션을 켜면, 텍스트는 개인화에서 제외되고 정량 점수만 사용된다.

에픽 8) 수익화(선택)

(사용자) 무료는 하루 N회 추천/검색, 유료 구독은 무제한 + 고급 필터(기름민감 최적화, 배달 안정성 지수 등)를 쓸 수 있다.

(사용자) 책(가이드북) 페이지의 QR을 스캔하면 앱의 해당 매장 상세로 바로 이동하고, 최신 상태(영업/평점/추천 메뉴)가 반영된다.


---

## 0. 아키텍처 개요 (권장)

### 클라이언트(앱)
- 2화면: **근처 리스트** / **지도**
- 위치 권한(사용 중) + 거부 시 “수동 지역 선택”
- 추천/검색 요청은 백엔드로, **키/모델 호출은 앱에 두지 않음**

### 백엔드(추천/AI 게이트웨이)
- 인증(익명 ID 가능), 로그 수집, 추천 계산, AI 호출, 캐시/레이트리밋
- 서비스 예: FastAPI / NestJS / Spring Boot 중 택1 (어떤 스택이든 설계 동일)

### DB
- 관계형(Postgres 등) + (선택) Redis 캐시
- 가게/메뉴/영업시간/태그/정량 점수/유저행동로그 저장

### Vector DB
- Pinecone / Qdrant / Weaviate 등
- 임베딩 대상: 리뷰 텍스트, 가게 요약, 메뉴 설명(옵션)
- 기능: **의미 검색**, **유사 매장/유사 리뷰**

### LLM
- 역할: 추천 결과에 대한 **설명문 생성**(입력은 “근거 데이터”로 제한)
- 금지: LLM이 새로운 가게를 만들어내거나 점수를 변경하는 것

---

## 1. 우선순위 백로그 (에픽 8개 기준)

> 표기: P0=즉시(MVP), P1=다음, P2=고도화, P3=나중(수익화/운영 최적화)

### P0 (MVP, 2~4주): “개인화 추천 + 2화면 UX”
- **Epic 1 온보딩 & 동의**
- **Epic 2 데이터 수집(평가/행동 로그)** — 최소
- **Epic 3 개인화 추천** — 핵심
- **Epic 4 지도/리스트 UX** — 핵심
- (Vector DB는 P0에서도 “유사 매장”만 가볍게 넣을 수 있음. 다만 추천 MVP만 보면 필수는 아님)

### P1 (1~2개월): “Vector DB로 의미 검색/유사도 + 신뢰 장치”
- **Epic 5 벡터DB 기반 검색 & 유사 매장**
- **Epic 6 품질/신뢰(미쉐린 느낌 유지)** — 최소 운영 도구

### P2 (2~4개월): “프라이버시/데이터 관리 + 추천 품질 개선”
- **Epic 7 계정/프라이버시/데이터 관리**
- Epic 3 고도화(로그 기반 가중치 자동 조정, A/B, 재랭킹)

### P3 (사업 단계): “수익화/확장”
- **Epic 8 수익화(선택)**

---

## 2. MVP 백로그 (P0) — 유저스토리 + 기술/구현

### Epic 1) 온보딩 & 동의 (P0)
#### US-1. 위치 권한 + 거부 시 대체 경로
- **As a** 신규 사용자  
- **I want** 위치 권한을 허용/거부해도 앱을 쓸 수 있고  
- **So that** 추천/검색을 시작할 수 있다.
- 구현:
  - 앱: 권한 요청(“앱 사용 중”), 거부 시 **수동 지역 선택(역/동 검색)** UI 제공
  - 서버: 요청에 좌표가 없으면 `area_code` 기반 추천 엔드포인트 지원
- 기술:
  - 모바일: Geolocator(Flutter) / CoreLocation(iOS) / FusedLocationProvider(Android)
  - 프라이버시: 좌표는 **격자화(예: 100~300m 단위 rounding)** 후 전송 옵션 제공

#### US-2. 추천 데이터 사용 동의 수준 선택
- 구현:
  - UI: 필수(서비스 이용) / 선택(개인화 로그, 리뷰 텍스트 활용) 분리
  - 서버: 사용자 설정 플래그 저장
- 기술:
  - DB: `user_consent` 테이블(옵션 플래그)
  - 로그 수집 시 consent 체크

#### US-3. 취향 30초 설정(슬라이더)
- 구현:
  - 슬라이더: 바삭, 기름민감, 간, 매운맛, 양념 선호, 가성비 등
  - 저장 후 즉시 추천 호출
- 기술:
  - DB: `user_pref` (각 항목 0~1 또는 0~10)
  - 추천 계산에 그대로 사용(가중합)

---

### Epic 2) 데이터 수집(평가/행동 로그) (P0 최소)
#### US-4. 간단 평가(정량 5항목)
- 구현:
  - 가게 상세에서 10초 평가 폼
  - 항목 예: 바삭/기름/간/양념/재주문(1~10)
- 기술:
  - DB: `rating` 테이블(유저ID/가게ID/항목/점수/타임스탬프)
  - 중복 방지: 동일 유저-가게 최근 N일 내 1회 제한(또는 누적 평균)
  - 추천: 가게 프로필(평균점수) 업데이트

#### US-5. 텍스트 리뷰 작성(임베딩 저장) — (P0에서 옵션)
- 구현:
  - 리뷰 저장 후 비동기로 임베딩 생성 → Vector DB upsert
- 기술:
  - 백그라운드 작업: Celery/RQ/Sidekiq/Quartz 등
  - 임베딩: `text-embedding-3-small` 같은 임베딩 모델(예시)
  - Vector DB metadata: `store_id`, `user_id`, `timestamp`, `tags`
  - 주의: consent(리뷰 텍스트 활용 동의) 없으면 임베딩/저장 제외

#### US-6. 저장(찜) / 관심없음(차단) 액션 로그
- 구현:
  - 찜/차단 버튼 → 즉시 추천에 반영
- 기술:
  - DB: `user_store_action` (like/dislike/block)
  - 추천에서 block은 제외, dislike는 점수 패널티

#### US-7. 상황 태그 선택(혼술/야식/가족/맥주)
- 구현:
  - 추천 화면 상단 태그 선택(토글)
- 기술:
  - 서버: `context` 파라미터로 전달
  - 룰: occasion별 가중치/필터 적용(예: 맥주=후라이드 가중치↑)

---

### Epic 3) 개인화 추천 (P0 핵심)
#### US-8. 현재 위치 기반 “오늘의 추천 5곳”
- 구현(서버 추천 파이프라인):
  1) 후보 필터: 반경/영업중/차단 제외/카테고리(치킨)  
  2) 1차 점수 계산(규칙/가중합)  
  3) Top N 선택  
  4) (옵션) LLM 설명문 생성(근거 기반)  
- 기술(점수 예시):
  - `distance_score` (0~1)
  - `taste_match` = 코사인 유사도 또는 가중합  
  - `quality_base` = 치맵 등급/평균점수/리뷰 신뢰도
  - `occasion_boost` = 상황 태그 보정
  - 최종: `score = 0.25*distance + 0.45*taste + 0.20*quality + 0.10*occasion`
- 데이터:
  - store_profile: `{crunch_avg, oily_avg, salty_avg, spicy_avg, saucy_avg, delivery_avg, ...}`
  - user_pref: `{crunch, oilySensitive, salty, spicy, saucy, value, ...}`

#### US-9. “왜 추천했는지” 한 줄 표시
- 구현:
  - LLM 없이도 가능: 서버가 규칙 기반 템플릿으로 생성  
    - 예: “바삭 선호(0.9)와 매장 바삭 평균(8.6) 매칭 상위”
  - LLM을 쓰면: 입력을 엄격히 제한(근거 숫자/태그만)
- 기술(LLM 사용 시):
  - 프롬프트에 **가게 후보 리스트는 주지 말고** “선정된 Top N의 근거 데이터”만 제공
  - 출력 포맷 고정(JSON 또는 1문장)

#### US-10. 정렬 변경(거리/취향매칭/가성비)
- 구현:
  - 서버에서 `sort=distance|match|value` 지원
- 기술:
  - 동일 후보셋을 재정렬(캐시 활용)

#### US-11. 비슷한 취향 사용자 인기 메뉴(옵션)
- P0에선 생략 가능. P1~P2에서 로그가 쌓이면 구현.
- 기술:
  - 유저-메뉴 상호작용 로그 → 집계 또는 임베딩 기반 유사 유저

#### US-12. 자연어 피드백(“이런 건 빼줘”) — P0에선 단순 UI로 대체 가능
- P1로 미루는 것을 권장.
- 기술:
  - LLM으로 문장 → `prefer/avoid` 규칙 JSON 변환
  - 룰 엔진에 반영

---

### Epic 4) 지도/리스트 UX (P0 핵심)
#### US-13. 리스트와 지도 결과 동기화
- 구현:
  - 리스트 화면의 결과를 상태로 유지 → 지도 화면은 같은 `store_ids`를 핀 표시
- 기술:
  - 상태관리(Flutter: Riverpod 등)
  - 지도 SDK: (선택) 네이버 지도 SDK 또는 대체 지도
  - MVP에서는 “길찾기/상세 지도”는 네이버지도 앱 딥링크로 전환 권장

#### US-14. 핀 탭 → 바텀시트(이유/대표메뉴/요약)
- 구현:
  - 핀 클릭 시 상세 카드 노출
- 기술:
  - 서버: `GET /stores/{id}` 상세 API
  - LLM 요약은 P1로 미루고 P0는 템플릿

#### US-15. “이 지역 다시 검색”
- 구현:
  - 지도 카메라 중심 좌표 + 반경 → 추천 재요청
- 기술:
  - 과도한 자동 호출 방지(버튼 기반)
  - 캐시 키: `(grid_lat, grid_lon, radius, occasion, user_id)`

---

## 3. P1 백로그 — Vector DB 중심(에픽 5~6)

### Epic 5) 벡터DB 기반 검색 & 유사 매장 (P1)
#### US-16. 문장 검색(의미 기반)
- 예: “겉바속촉 + 기름 냄새 적은 곳”
- 구현:
  1) query 임베딩 생성  
  2) Vector DB에서 topK 검색(리뷰/요약 벡터)  
  3) 나온 store_id 집계 → 후보 리스트 구성  
  4) 거리/영업중/차단 필터 후 표시  
- 기술:
  - Vector DB 스키마:
    - index: `review_vectors`
    - vector: embedding
    - metadata: `store_id`, `sentiment`, `tags`, `created_at`
  - 집계: `store_id`별 score 합산/최댓값

#### US-17. “이 가게랑 비슷한 곳”
- 구현:
  - store 대표 벡터(리뷰 요약 벡터 또는 store_summary 벡터)를 만들어 둠
  - 해당 벡터로 Vector DB에서 nearest 검색
- 기술:
  - 대표 벡터 생성 전략:
    - (1) 최신 리뷰 N개 요약 텍스트 → 임베딩
    - (2) 정량 프로필을 문장화(템플릿) → 임베딩 (가벼움)

#### US-18. 메뉴 단위 유사 추천(옵션)
- 구현:
  - 메뉴 설명/리뷰를 메뉴ID에 매핑하여 임베딩
- 기술:
  - 메뉴 데이터 품질이 낮으면 후순위

---

### Epic 6) 품질/신뢰(미쉐린 느낌) (P1)
#### US-19. 광고/어뷰징 의심 리뷰 신고 + 1차 분류
- 구현:
  - 신고 → 운영자 큐
  - 간단 분류: 금칙어/링크/반복 패턴 + (옵션) 텍스트 분류 모델
- 기술:
  - moderation(모델 or 룰)
  - audit log

#### US-20. 운영자: 치맵 셀렉트 선정/해제 + 근거 기록
- 구현:
  - 운영자 페이지(간단 Admin)
- 기술:
  - DB: `store_badge`(select, best_buy, delivery_king 등), `badge_reason`

#### US-21. 정책 문구/투명성 표시
- 구현:
  - 앱/책 서문 수준의 정책 텍스트 고정 노출
- 기술:
  - 버전 관리(정책 변경 이력)

---

## 4. P2 백로그 — 프라이버시/품질 고도화(에픽 7 + 추천 고도화)

### Epic 7) 계정/프라이버시/데이터 관리 (P2)
#### US-22. 추천 프로필 확인/수정
- 구현: 내 취향 슬라이더 + 태그
- 기술: `user_pref` CRUD

#### US-23. 데이터 내려받기/삭제
- 구현: 내 리뷰/로그 내보내기, 삭제 요청
- 기술: GDPR/개인정보 대응 패턴(soft delete, anonymize)

#### US-24. “리뷰 텍스트 추천 사용 안 함” 옵션
- 구현: consent toggle
- 기술: 임베딩/벡터 upsert/조회에서 제외

### 추천 고도화(에픽 3 확장)
- 클릭/재방문 로그 기반 가중치 자동 조정
- re-ranking: 규칙 기반 Top 50 → 간단 ML로 Top 5 재정렬
- A/B 실험, 오프라인 평가(Precision@K)

---

## 5. P3 백로그 — 수익화(에픽 8)

### Epic 8) 수익화(선택) (P3)
#### US-25. 무료/유료 추천 제한 + 고급 필터
- 기술: 레이트리밋, 결제, entitlement

#### US-26. 책 QR → 앱 상세 연결
- 기술: 딥링크 라우팅, 캠페인 파라미터

---

## 6. 데이터 모델 초안 (관계형 DB)

### 핵심 테이블
- `users`
  - `id`, `created_at`, `anon_device_id`, `consent_flags`
- `user_pref`
  - `user_id`, `crunch`, `oily_sensitive`, `salty`, `spicy`, `saucy`, `value`, `updated_at`
- `stores`
  - `id`, `name`, `lat`, `lon`, `address`, `phone`, `tags[]`, `created_at`
- `store_hours`
  - `store_id`, `dow`, `open_time`, `close_time`, `is_closed`
- `store_profile`
  - `store_id`, `crunch_avg`, `oily_avg`, `salty_avg`, `saucy_avg`, `value_avg`, `rating_count`, ...
- `ratings`
  - `id`, `user_id`, `store_id`, `crunch`, `oily`, `salty`, `saucy`, `revisit`, `created_at`
- `reviews`
  - `id`, `user_id`, `store_id`, `text`, `created_at`, `is_deleted`
- `user_store_action`
  - `user_id`, `store_id`, `action`(like/dislike/block), `created_at`
- `events`
  - `id`, `user_id`, `type`(view/click/nav), `store_id`, `meta_json`, `created_at`
- `store_badge`
  - `store_id`, `badge_type`, `reason`, `issued_at`, `issued_by`

---

## 7. Vector DB 설계 초안

### 컬렉션/인덱스
1) `review_vectors`
- vector: 리뷰 텍스트 임베딩
- metadata: `review_id`, `store_id`, `user_id?(옵션)`, `created_at`, `tags`, `sentiment?(옵션)`

2) `store_vectors` (유사 매장용)
- vector: 매장 대표 임베딩(요약 텍스트)
- metadata: `store_id`, `updated_at`, `tags`

### 임베딩 파이프라인
- 리뷰 생성/수정 이벤트 발생
  - (consent=true) → 작업큐에 `embed(review_id)` push
  - 임베딩 생성 → `review_vectors.upsert`
- 매장 대표 벡터 재생성(주기적 또는 리뷰 N개마다)
  - 최근 리뷰 요약 텍스트 생성(룰/LLM) → 임베딩 → `store_vectors.upsert`

---

## 8. API 설계 초안 (REST 예시)

### 추천/검색
- `POST /recommend`
  - body: `{ lat, lon, radius, occasion, sort, user_id }`
  - resp: `[ {store_id, score, reason_line, distance_m, badges[]} ]`
- `POST /search/semantic`
  - body: `{ query, lat, lon, radius, user_id }`
  - resp: `[store...]`

### 스토어/평가/리뷰
- `GET /stores/{id}`
- `POST /ratings`
- `POST /reviews`
- `POST /stores/{id}/action` (like/dislike/block)

### 운영자(후순위)
- `POST /admin/stores/{id}/badge`

---

## 9. 구현 팁 (실패/품질/비용)

### 추천 안정성
- LLM 없이도 **reason_line 템플릿**부터 구현(테스트 쉬움)
- LLM을 쓰면:
  - 입력은 숫자/태그/짧은 특징만
  - 출력 포맷 고정(JSON)
  - 실패 시 템플릿으로 폴백

### 캐시/레이트리밋
- 추천 응답 캐시(5~30분): `(user_id, grid_location, radius, occasion, sort)`
- 무료 사용자는 일일 추천/검색 제한(나중에)

### 데이터 품질
- 정량 항목은 반드시 “짧고 강제”로 유지(5~7개)
- 텍스트 리뷰는 선택(동의/비동의 분리)

### 벡터DB 비용/운영
- 처음엔 `review_vectors`만으로도 의미 검색 가능
- 유사 매장 기능은 `store_vectors`가 있으면 훨씬 간단

---

## 10. 개발 순서 체크리스트 (권장)

1) DB 스키마 + 기본 CRUD(Stores, Ratings, UserPref)  
2) 추천 엔진 v1(규칙/가중합) + 리스트 화면 연결  
3) 지도 화면 + 결과 동기화 + “이 지역 다시 검색”  
4) 로그 수집(events) + 차단/찜 반영  
5) (옵션) LLM reason_line 생성(실패 시 템플릿 폴백)  
6) Vector DB 연결: 리뷰 임베딩 upsert  
7) 의미 검색 + 유사 매장(가치 큰 기능부터)  
8) 운영자 최소 도구(셀렉트 배지)  

---

## 11. Definition of Done(간단 기준)

- 추천: 동일 사용자/상황에서 결과가 일관되며, 근거가 1줄로 설명됨  
- 지도/리스트: 동일 후보가 두 화면에서 유지되고 필터가 깨지지 않음  
- 벡터: 리뷰 작성 후 일정 시간 내 의미 검색에 반영됨(비동기 OK)  
- 프라이버시: 동의 설정에 따라 텍스트 임베딩 저장이 on/off됨  

---

## 12. 다음에 정해야 할 3가지(설계 고정 포인트)

1) **정량 항목(5~7개) 최종 확정** + 각 항목 정의(1~10 기준)  
2) 추천 점수 가중치 초기값 + 상황(혼술/야식/가족/맥주) 룰  
3) 임베딩 대상 우선순위: 리뷰 텍스트만? + store_summary도 만들지?  

